generator client {
  provider = "prisma-client"
  output   = "../src/generated/prisma"
}

datasource db {
  provider = "postgresql"
}

enum Role {
  ADMIN
  CUSTOMER
}

enum OrganizationRole {
  OWNER
  ADMIN
  MEMBER
  CREATOR
}

enum EventStatus {
  PUBLISHED
  CANCELLED
  COMPLETED
}

enum CreditPackage {
  SMALL
  MEDIUM
  LARGE
}

enum OtpPurpose {
  FORGOT_PASSWORD
  RESET_PASSWORD
}

enum NotificationType {
  EVENT_CREATED
  EVENT_UPDATED
  EVENT_REMINDER
  EVENT_CANCELLED
  ORG_APPROVED
  PAYMENT_SUCCESS
}

enum NotificationEntity {
  EVENT
  ORGANIZATION
  USER
  PAYMENT
}

enum OrganizationType {
  INDIVIDUAL
  COMPANY
  EDUCATIONAL
  COMMUNITY
  NON_PROFIT
  GOVERNMENT
}

enum EventType {
  WORKSHOP
  MEETUP
  CONFERENCE
  WEBINAR
  HACKATHON
  COMPETITION
  OTHER
}

model User {
  id        String   @id @default(cuid())
  email     String   @unique
  name      String
  phone     String?
  password  String?
  role      Role     @default(CUSTOMER)
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
  image     String?

  //relation of the user table to the other table 
  session            Session[]
  organizationMember OrganizationMember[]
  createdEvents      Event[]
  creditPurchases    CreditPurchase[]
  userInteractions   UserInteraction[]
  eventParticipants  EventParticipants[]
  userEmbedding      UserEmbedding?
  notifications      Notification[]
  otpdetails         Otpdetails[]
}

model Otpdetails {
  id        String     @id @default(uuid())
  userId    String
  otp       String     @unique
  purpose   OtpPurpose
  expiresAt DateTime
  used      Boolean    @default(false)
  createdAt DateTime   @default(now())

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([userId])
}

//session table to store user loggedin details and past sessions of an use r
model Session {
  id           String   @id @default(cuid())
  userId       String
  accessToken  String   @unique
  refreshToken String   @unique
  expiresOn    DateTime
  createdAt    DateTime @default(now())
  updatedAt    DateTime @updatedAt
  user         User     @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([userId])
  @@index([accessToken])
  @@index([refreshToken])
}

// organization table 
model Organization {
  id              String               @id @default(cuid())
  name            String
  thumbnail       String?
  image           String?
  website         String?
  description     String
  type            OrganizationType     @default(INDIVIDUAL)
  credits         Int                  @default(20)
  lastCreditReset DateTime             @default(now())
  isPremium       Boolean              @default(false)
  createdAt       DateTime             @default(now())
  updatedAt       DateTime             @updatedAt
  members         OrganizationMember[]
  events          Event[]
  creditPurchases CreditPurchase[]

  @@index([name])
}

model OrganizationMember {
  id             String           @id @default(cuid())
  userId         String
  organizationId String
  role           OrganizationRole @default(MEMBER)
  joinedAt       DateTime         @default(now())

  user         User         @relation(fields: [userId], references: [id])
  organization Organization @relation(fields: [organizationId], references: [id], onDelete: Cascade)

  @@unique([userId, organizationId])
  @@index([userId])
  @@index([organizationId])
  @@index([role])
}

model Event {
  id             String @id @default(cuid())
  organizationId String
  creatorId      String

  title       String
  description String
  location    String

  startDate DateTime
  endDate   DateTime

  capacity        Int
  registeredCount Int @default(0)

  status EventStatus @default(PUBLISHED)

  // recommendation metadata
  category EventType @default(OTHER)
  tags     String[]
  image    String?

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  // relations
  organization Organization        @relation(fields: [organizationId], references: [id], onDelete: Cascade)
  creator      User                @relation(fields: [creatorId], references: [id])
  participants EventParticipants[]

  eventEmbedding   EventEmbedding?
  eventMetrics     EventMetrics?
  userInteractions UserInteraction[]

  @@index([organizationId])
  @@index([creatorId])
  @@index([startDate])
  @@index([status])
  @@index([category])
  @@index([status, startDate])
  @@index([organizationId, status])
}

model EventParticipants {
  id      String @id @default(cuid())
  eventId String
  userId  String

  registeredAt DateTime @default(now())

  // attendance verification
  checkInToken   String?
  tokenExpiresAt DateTime?
  attended       Boolean   @default(false)
  checkedInAt    DateTime?

  // cancellation
  isCancelled Boolean   @default(false)
  cancelledAt DateTime?

  event Event @relation(fields: [eventId], references: [id], onDelete: Cascade)
  user  User  @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([eventId, userId])
  @@index([eventId])
  @@index([userId])
  @@index([attended])
}

model CreditPurchase {
  id             String        @id @default(cuid())
  organizationId String
  purchasedBy    String
  package        CreditPackage
  credits        Int
  amount         Float

  purchasedAt DateTime @default(now())

  organization Organization @relation(fields: [organizationId], references: [id], onDelete: Cascade)
  user         User         @relation(fields: [purchasedBy], references: [id])

  @@index([organizationId])
  @@index([purchasedBy])
}

model Notification {
  id     String @id @default(cuid())
  userId String

  title   String
  message String

  type       NotificationType
  entityType NotificationEntity
  entityId   String?

  isRead    Boolean  @default(false)
  createdAt DateTime @default(now())

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([userId, isRead])
  @@index([userId, createdAt])
}

// ========= Tables Machine Learning and Algorithms ===================== //
// ========= flow => React => Node => Django returns json(recommedations) => Node => React (Display recommendations)============/

model UserEmbedding {
  id        String   @id @default(cuid())
  userId    String   @unique
  embedding Float[] // 768-dim vector
  updatedAt DateTime @updatedAt

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([userId])
}

//! BERT EMBEDDING FOR CONTENT BASED RECOMMENDATION 
model EventEmbedding {
  id        String   @id @default(cuid())
  eventId   String   @unique
  embedding Float[] // 768-dimensional BERT vector
  updatedAt DateTime @updatedAt
  event     Event    @relation(fields: [eventId], references: [id], onDelete: Cascade)

  @@index([eventId])
}

model UserInteraction {
  id        String   @id @default(cuid())
  userId    String
  eventId   String
  createdAt DateTime @default(now())
  user      User     @relation(fields: [userId], references: [id])
  event     Event    @relation(fields: [eventId], references: [id])

  @@unique([userId, eventId])
  @@index([userId])
  @@index([eventId])
  @@index([createdAt])
  @@index([eventId, createdAt])
}

/// the final recommendation will be mix of both ie BERT and Cosine 

// Data required for the Linear regression 
model EventMetrics {
  id                 String   @id @default(cuid())
  eventId            String   @unique
  totalViews         Int      @default(0)
  totalRegistrations Int      @default(0)
  totalAttendees     Int      @default(0)
  updatedAt          DateTime @updatedAt

  event Event @relation(fields: [eventId], references: [id], onDelete: Cascade)

  @@index([eventId])
}

// Admin Panel Predictions (4 key metrics) prediction will alwayes be for next month we canchange it 
model AdminPrediction {
  id                         String @id @default(cuid())
  predictedEventCount        Int
  predictedTotalParticipants Int
  predictedAverageAttendance Float
  predictedPopularCategory   String

  predictionMonth String
  confidence      Float
  generatedAt     DateTime @default(now())

  @@index([predictionMonth])
  @@index([generatedAt])
}
